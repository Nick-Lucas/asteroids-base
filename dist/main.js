!function(n){var e={};function t(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return n[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)t.d(o,i,function(e){return n[e]}.bind(null,i));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/GameEngine.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n/**\n * Basic game class constructor\n * @param {String} canvasSelector\n * @param {String} scoreSelector\n */\nvar GameEngine = function GameEngine(canvasSelector, scoreSelector) {\n  var cnv = document.querySelector(canvasSelector) || document.querySelector("canvas");\n  var ctx = cnv.getContext("2d");\n  var scr = document.querySelector(scoreSelector);\n  var w = 320;\n  var h = 240; // Setting defualt leaderboard data\n\n  if (typeof Storage !== "undefined") {\n    localStorage["board.0.name"] = "John Doe";\n    localStorage["board.0.score"] = 9990;\n    localStorage["board.1.name"] = "Artem N";\n    localStorage["board.1.score"] = 1700;\n  }\n\n  var engine = {\n    canvas: cnv,\n    context: ctx,\n    score: 0,\n    objects: [],\n    input: {\n      mouse: {\n        x: 0,\n        y: 0\n      },\n      fire: false,\n      left: false,\n      right: false,\n      forward: false\n    }\n  };\n  /* Input events */\n\n  engine.canvas.addEventListener("mousemove", function (e) {\n    engine.input.mouse.x = e.layerX;\n    engine.input.mouse.y = e.layerY;\n  });\n  document.addEventListener("keydown", function (e) {\n    switch (e.keyCode) {\n      case 32:\n        engine.input.fire = true;\n        break;\n      // Left:\n\n      case 37:\n        engine.input.left = true;\n        break;\n\n      case 65:\n        engine.input.left = true;\n        break;\n      // Right:\n\n      case 39:\n        engine.input.right = true;\n        break;\n\n      case 68:\n        engine.input.right = true;\n        break;\n      // Forward:\n\n      case 38:\n        engine.input.forward = true;\n        break;\n\n      case 87:\n        engine.input.forward = true;\n        break;\n    }\n  });\n  document.addEventListener("keyup", function (e) {\n    switch (e.keyCode) {\n      case 32:\n        engine.input.fire = false;\n        break;\n      // Left:\n\n      case 37:\n        engine.input.left = false;\n        break;\n\n      case 65:\n        engine.input.left = false;\n        break;\n      // Right:\n\n      case 39:\n        engine.input.right = false;\n        break;\n\n      case 68:\n        engine.input.right = false;\n        break;\n      // Forward:\n\n      case 38:\n        engine.input.forward = false;\n        break;\n\n      case 87:\n        engine.input.forward = false;\n        break;\n    }\n  });\n  /* Get each object by name */\n\n  engine.eachByName = function (name, callback) {\n    var n = name || "";\n\n    var c = callback || function () {\n      console.exception("Callback is undefined");\n    };\n\n    for (var i = 0; i < this.objects.length; i++) {\n      if (this.objects[i].name == n) {\n        c(this.objects[i], i);\n      }\n    }\n  };\n  /* Basic engine functions */\n\n\n  var Load = function Load() {\n    engine.canvas.width = Math.max(document.documentElement.clientWidth, window.innerWidth || w);\n    engine.canvas.height = Math.max(document.documentElement.clientHeight, window.innerHeight || h) - 48;\n\n    for (var i = 0; i < engine.objects.length; i++) {\n      engine.objects[i].Start();\n    }\n  };\n\n  var Update = function Update() {\n    var prevScore = engine.score; // Clear canvas\n\n    engine.context.clearRect(0, 0, engine.canvas.width, engine.canvas.height); // Delete unused objects\n\n    for (var i = 0; i < engine.objects.length; i++) {\n      if (engine.objects[i].delete) {\n        engine.objects.splice(i, 1);\n      }\n    } // Update objects\n\n\n    for (var j = 0; j < engine.objects.length; j++) {\n      engine.objects[j].Update();\n      engine.objects[j].Draw(engine.context);\n    } // Update score\n\n\n    if (engine.score > prevScore) {\n      scr.innerHTML = engine.score;\n    } // Game loop\n\n\n    window.requestAnimFrame(Update);\n  };\n\n  engine.Run =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee() {\n    var wait;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            wait = function wait() {\n              return new Promise(function (resolve) {\n                setTimeout(function () {\n                  resolve();\n                }, 5000);\n              });\n            };\n\n            _context.next = 3;\n            return wait();\n\n          case 3:\n            Load();\n            Update();\n\n          case 5:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return engine;\n};\n// CONCATENATED MODULE: ./src/Polygon.js\n/**\n * Constructor for objects that would be rendered.\n * @param {Object} options\n */\nvar Polygon = function Polygon(options) {\n  var name = options.name || "Polygon";\n  var color = options.color || "#0F0";\n  var points = options.points || [{\n    x: 0,\n    y: 0\n  }, {\n    x: 10,\n    y: 10\n  }, {\n    x: 10,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 10\n  }, {\n    x: 10,\n    y: 10\n  }];\n  var pos = options.position || {\n    x: 0,\n    y: 0\n  };\n  var vel = options.velocity || {\n    x: 0,\n    y: 0\n  };\n  var size = options.size || {\n    x: 100,\n    y: 100\n  };\n  var base = options.base || {\n    x: 50,\n    y: 50\n  };\n  var p = {\n    name: name,\n    position: pos,\n    velocity: vel,\n    color: color,\n    points: points,\n    rotation: 0,\n    base: base,\n    size: size,\n    newcnv: document.createElement("canvas"),\n    delete: false\n  };\n  p.newctx = p.newcnv.getContext("2d");\n  p.newcnv.width = p.size.x;\n  p.newcnv.height = p.size.y;\n\n  p.constructor.prototype.Start = function () {};\n\n  p.constructor.prototype.Update = function () {};\n\n  p.Draw = function (ctx) {\n    this.newctx.clearRect(0, 0, this.newcnv.width, this.newcnv.height);\n    this.newctx.save();\n    this.newctx.translate(this.base.x, this.base.y);\n    this.newctx.beginPath();\n    this.newctx.moveTo(this.points[0].x, this.points[0].y);\n\n    for (var i = 1; i < this.points.length; i++) {\n      this.newctx.lineTo(this.points[i].x, this.points[i].y);\n    }\n\n    this.newctx.closePath();\n    this.newctx.shadowBlur = 5;\n    this.newctx.shadowColor = this.color;\n    this.newctx.strokeStyle = this.color;\n    this.newctx.stroke();\n    this.newctx.restore(); // Draw this object 8 times to simulate closed space near canvas edges.\n\n    ctx.save();\n    ctx.translate(this.position.x, this.position.y); // 0\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x - ctx.canvas.width, this.position.y); // 1\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x + ctx.canvas.width, this.position.y); // 2\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x, this.position.y - ctx.canvas.height); // 3\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x, this.position.y + ctx.canvas.height); // 4\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x - ctx.canvas.width, this.position.y - ctx.canvas.height); // 5\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x + ctx.canvas.width, this.position.y - ctx.canvas.height); // 6\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x - ctx.canvas.width, this.position.y + ctx.canvas.height); // 7\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n    ctx.save();\n    ctx.translate(this.position.x + ctx.canvas.width, this.position.y + ctx.canvas.height); // 8\n\n    ctx.rotate(this.rotation * Math.PI / 180);\n    ctx.drawImage(this.newcnv, -this.base.x, -this.base.y);\n    ctx.restore();\n  };\n\n  return p;\n};\n// CONCATENATED MODULE: ./src/Helpers.js\n/* Helpers */\n\n/**\n * Checks intersection between 2 lines\n * @param {Object} v1 \t{x: Number, y: Number}\n * @param {Object} v2 \t{x: Number, y: Number}\n * @param {Object} v3 \t{x: Number, y: Number}\n * @param {Object} v4 \t{x: Number, y: Number}\n */\nfunction CheckIntersection(v1, v2, v3, v4) {\n  var n1, n2, n3, n4;\n  n1 = (v4.x - v3.x) * (v1.y - v3.y) - (v4.y - v3.y) * (v1.x - v3.x);\n  n2 = (v4.x - v3.x) * (v2.y - v3.y) - (v4.y - v3.y) * (v2.x - v3.x);\n  n3 = (v2.x - v1.x) * (v3.y - v1.y) - (v2.y - v1.y) * (v3.x - v1.x);\n  n4 = (v2.x - v1.x) * (v4.y - v1.y) - (v2.y - v1.y) * (v4.x - v1.x);\n  return n1 * n2 < 0 && n3 * n4 < 0;\n}\n/**\n * Checks if point is inside the polygon\n * @param {Object} p    \t{x: Number, y: Number}\n * @param {Array}  poly \tArray of objects: {x: Number, y: Number}\n */\n\nfunction CheckPointInPoly(p, poly) {\n  for (var i = 0, j = poly.length - 1, res = false; i < poly.length; j = i++) {\n    var v1 = {\n      x: poly[i].x,\n      y: poly[i].y\n    };\n    var v2 = {\n      x: poly[j].x,\n      y: poly[j].y\n    };\n    if (v1.y > p.y != v2.y > p.y && p.x < (v2.x - v1.x) * (p.y - v1.y) / (v2.y - v1.y) + v1.x) res = !res;\n  }\n\n  return res;\n}\n/**\n * Rotate point around center on certain angle\n * @param {Object} p      \t{x: Number, y: Number}\n * @param {Object} center \t{x: Number, y: Number}\n * @param {Number} angle  \tAngle in radians\n */\n\nfunction RotatePoint(p, center, angle) {\n  return {\n    x: (p.x - center.x) * Math.cos(angle) - (p.y - center.y) * Math.sin(angle) + center.x,\n    y: (p.x - center.x) * Math.sin(angle) + (p.y - center.y) * Math.cos(angle) + center.y\n  };\n}\n/**\n * Generates vertices for asteroid polygon with certain count and radius\n * @param  {Number} count \tNumber of vertices\n * @param  {Number} rad   \tMaximal radius of polygon\n * @return {Array}       \tArray of vertices: {x: Number, y: Number}\n */\n\nfunction asteroidVertices(count, rad) {\n  var p = [];\n\n  for (var i = 0; i < count; i++) {\n    p[i] = {\n      x: (-Math.sin(360 / count * i * Math.PI / 180) + Math.round(Math.random() * 2 - 1) * Math.random() / 3) * rad,\n      y: (-Math.cos(360 / count * i * Math.PI / 180) + Math.round(Math.random() * 2 - 1) * Math.random() / 3) * rad\n    };\n  }\n\n  return p;\n}\n/**\n * Shows message box at the end of game\n * @param {String} selector\n * @param {Number} score\n */\n\nfunction EngGameMessage(selector, score) {\n  var scores = []; // If local storage existsâ€¦\n\n  if (typeof Storage !== "undefined") {\n    // Reading storage for saved scores\n    for (var i = 0; i < localStorage.length; i++) {\n      if (typeof localStorage["board." + i + ".name"] !== "undefined") {\n        scores.push({\n          name: localStorage["board." + i + ".name"],\n          score: localStorage["board." + i + ".score"]\n        });\n      }\n    } // Sorting leaderboard\n\n\n    scores.sort(function (a, b) {\n      return b.score - a.score;\n    }); // Prepare html to show\n\n    var html = "<ol class=\\"b-scores\\">";\n\n    for (var j = 0; j < scores.length; j++) {\n      html += "<li class=\\"b-scores__box\\">";\n\n      if (score > scores[j].score) {\n        html += "Your score: " + score + ". <input onchange=\\"SaveName(this)\\" value=\\"\\" autofocus=\\"autofocus\\" type=\\"text\\" placeholder=\\"Enter your name\\" class=\\"b-scores__input\\" \\/><\\/li><li class=\\"b-scores__box\\">";\n        score = 0;\n      }\n\n      html += scores[j].score + ": " + scores[j].name + "<\\/li>";\n    }\n\n    if (score !== 0) {\n      html += "<li class=\\"b-scores__box\\">Your score: " + score + ". <input onchange=\\"SaveName(this)\\" value=\\"\\" autofocus=\\"autofocus\\" type=\\"text\\" placeholder=\\"Enter your name\\" class=\\"b-scores__input\\" \\/><\\/li>";\n    }\n\n    html += "<\\/ol>";\n    document.querySelector(selector).innerHTML = html;\n  }\n}\n/**\n * Saves score in local storage\n * @param {Number}    score\n * @param {HTML node} node\n */\n\nfunction SaveScore(score, node, game) {\n  if (score > 0 && typeof Storage !== "undefined") {\n    var k = 0;\n\n    for (var i = 0; i < localStorage.length; i++) {\n      if (typeof localStorage["board." + i + ".name"] !== "undefined") {\n        k = i + 1;\n      }\n    }\n\n    localStorage["board." + k + ".name"] = game.name;\n    localStorage["board." + k + ".score"] = score;\n    node.innerHTML = "Done!";\n  }\n}\n/**\n * Saves name from input into global variable\n * @param {HTML node} node\n */\n\nfunction SaveName(node, game) {\n  game.name = node.value;\n}\n/**\n * Changes polygon and page color\n * @param {Number} color \tColor code: 0 - green, 1 - red, 2 - blue.\n */\n\nfunction ChangeGameColor(color, game) {\n  var c = "#0F0";\n  var page = document.querySelector("body");\n\n  switch (color) {\n    case 1:\n      c = "#F00";\n      page.className = "m-red";\n      break;\n\n    case 2:\n      c = "#06F";\n      page.className = "m-blue";\n      break;\n\n    default:\n      c = "#0F0";\n      page.className = "m-green";\n  }\n\n  for (var i = 0; i < game.objects.length; i++) {\n    game.objects[i].color = c;\n  }\n\n  game.color = c;\n  localStorage["game.color"] = c;\n}\n// CONCATENATED MODULE: ./src/Asteroid.js\n\n\n/**\n * Asteroid constructor\n * @param {Number} rad \t\tAsteroid radius.\n */\n\nvar Asteroid_Asteroid = function Asteroid(rad, game) {\n  var asteroid = new Polygon({\n    points: asteroidVertices(Math.max(Math.floor(rad / 5), 3), rad),\n    color: game.color,\n    name: "asteroid",\n    size: {\n      x: 210,\n      y: 210\n    },\n    base: {\n      x: 105,\n      y: 105\n    },\n    velocity: {\n      x: (Math.random() * 2 - 1) * Math.random() * 2,\n      y: (Math.random() * 2 - 1) * Math.random() * 2\n    },\n    position: {\n      x: Math.random() * 500,\n      y: Math.random() * 1000\n    }\n  });\n\n  asteroid.Start = function () {\n    this.rotationSpeed = (Math.random() * 2 - 1) * Math.random() * 2;\n    this.radius = rad;\n    this.score = 80 / this.radius * 5;\n  };\n\n  asteroid.Update = function () {\n    this.position.x += this.velocity.x;\n    this.position.y += this.velocity.y; // Teleporting on edges\n\n    if (this.position.x > game.canvas.width) {\n      this.position.x -= game.canvas.width;\n    }\n\n    if (this.position.x < 0) {\n      this.position.x += game.canvas.width;\n    }\n\n    if (this.position.y > game.canvas.height) {\n      this.position.y -= game.canvas.height;\n    }\n\n    if (this.position.y < 0) {\n      this.position.y += game.canvas.height;\n    } // Set rotation\n\n\n    this.rotation += this.rotationSpeed;\n\n    if (this.rotation >= 360) {\n      this.rotation -= 360;\n    }\n\n    if (this.rotation < 0) {\n      this.rotation += 360;\n    }\n  };\n\n  return asteroid;\n};\n// CONCATENATED MODULE: ./src/Burst.js\n\n/**\n * Burst constructor\n * @param {Object} options\n */\n\nvar Burst_Burst = function Burst(options, game) {\n  var length = options.length || 10;\n  var count = options.count || 36;\n  var color = options.color || "#F00";\n  var name = options.name || "burst";\n  var pos = options.position || {\n    x: 0,\n    y: 0\n  };\n  var speed = options.speed || 10;\n  var obj = {\n    delete: false,\n    radius: 0,\n    count: count,\n    color: color,\n    name: name,\n    position: pos,\n    length: length\n  };\n\n  obj.Start = function () {};\n\n  obj.Update = function () {\n    this.radius += speed;\n\n    if (this.radius > game.canvas.width || this.radius > game.canvas.height) {\n      this.delete = true;\n    }\n  };\n\n  obj.Draw = function (ctx) {\n    ctx.save();\n    ctx.translate(this.position.x, this.position.y);\n    ctx.beginPath();\n\n    for (var i = 0; i < this.count; i++) {\n      var v1 = RotatePoint({\n        x: 0,\n        y: this.radius\n      }, {\n        x: 0,\n        y: 0\n      }, 2 / this.count * i * Math.PI);\n      var v2 = RotatePoint({\n        x: 0,\n        y: this.radius + this.length\n      }, {\n        x: 0,\n        y: 0\n      }, 2 / this.count * i * Math.PI);\n      ctx.moveTo(v1.x, v1.y);\n      ctx.lineTo(v2.x, v2.y);\n    }\n\n    ctx.closePath();\n    ctx.strokeStyle = this.color;\n    ctx.shadowColor = this.color;\n    ctx.shadowBlur = 5;\n    ctx.stroke();\n    ctx.restore();\n  };\n\n  return obj;\n};\n// CONCATENATED MODULE: ./src/Bullet.js\n\n\n\n\n/**\n * Bullet constructor\n */\n\nvar Bullet_Bullet = function Bullet(game, ship) {\n  var bul = new Polygon({\n    points: [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: -5\n    }],\n    size: {\n      x: 10,\n      y: 15\n    },\n    base: {\n      x: 5,\n      y: 10\n    },\n    color: game.color,\n    name: "bullet"\n  });\n\n  bul.Start = function () {\n    var posDelta = RotatePoint({\n      x: 0,\n      y: -20\n    }, {\n      x: 0,\n      y: 0\n    }, ship.rotation * Math.PI / 180);\n    this.position = {\n      x: ship.position.x + posDelta.x,\n      y: ship.position.y + posDelta.y\n    };\n    this.rotation = ship.rotation;\n    this.velocity = {\n      x: posDelta.x / 2,\n      y: posDelta.y / 2\n    };\n  };\n\n  bul.Update = function () {\n    // Move\n    this.position.x += this.velocity.x;\n    this.position.y += this.velocity.y; // Check for intersection with asteroid\n\n    var pos = this.position;\n    var collision = false;\n    game.eachByName("asteroid", function (node) {\n      // Check if close enough\n      if (Math.sqrt((node.position.x - pos.x) * (node.position.x - pos.x) + (node.position.y - pos.y) * (node.position.y - pos.y)) < node.radius) {\n        // Prepare vertices data\n        var verts = [];\n\n        for (var i = 0; i < node.points.length; i++) {\n          var np = RotatePoint(node.points[i], {\n            x: 0,\n            y: 0\n          }, node.rotation * Math.PI / 180);\n          verts.push({\n            x: np.x + node.position.x,\n            y: np.y + node.position.y\n          });\n        } // Checking\n\n\n        if (CheckPointInPoly(pos, verts)) {\n          collision = true;\n          var r = node.radius / 2;\n\n          if (r > 5) {\n            var ast1 = new Asteroid_Asteroid(node.radius / 2, game);\n            var ast2 = new Asteroid_Asteroid(node.radius / 2, game);\n            ast1.Start();\n            ast2.Start();\n            ast1.velocity = RotatePoint(node.velocity, {\n              x: 0,\n              y: 0\n            }, 10 * Math.PI / 180);\n            ast2.velocity = RotatePoint(node.velocity, {\n              x: 0,\n              y: 0\n            }, 360 - 10 * Math.PI / 180);\n            ast1.position = {\n              x: node.position.x + ast1.velocity.x,\n              y: node.position.y + ast1.velocity.y\n            };\n            ast2.position = {\n              x: node.position.x + ast2.velocity.x,\n              y: node.position.y + ast2.velocity.y\n            };\n            game.objects.push(ast1, ast2);\n          } else {\n            var burst = new Burst_Burst({\n              position: node.position,\n              color: game.color\n            }, game);\n            game.objects.push(burst);\n          }\n\n          node.delete = true;\n          game.score += node.score;\n        }\n      }\n    });\n\n    if (collision) {\n      this.delete = true;\n    } // Delete if it goes out of world bounds\n\n\n    if (this.position.x < 0 || this.position.y < 0 || this.position.x > game.canvas.width || this.position.y > game.canvas.height) {\n      this.delete = true;\n    }\n  };\n\n  return bul;\n};\n// CONCATENATED MODULE: ./src/Ship.js\n\n\n\n\n\nfunction makeShip(game) {\n  /* Adding ship */\n  var ship = new Polygon({\n    points: [{\n      x: 0,\n      y: 0\n    }, {\n      x: 10,\n      y: 10\n    }, {\n      x: 0,\n      y: -20\n    }, {\n      x: -10,\n      y: 10\n    }],\n    color: game.color,\n    name: "ship",\n    size: {\n      x: 30,\n      y: 45\n    },\n    base: {\n      x: 15,\n      y: 25\n    }\n  });\n\n  ship.Start = function () {\n    this.position = {\n      x: game.canvas.width / 2,\n      y: game.canvas.height / 2\n    };\n    this.rotationSpeed = 7;\n    this.speed = 0.2;\n    this.inertia = 0;\n    this.inertiaMax = 0.99;\n    this.shootDate = 0;\n  };\n\n  ship.Update = function () {\n    // Rotate\n    if (game.input.left) {\n      this.rotation -= this.rotationSpeed;\n    }\n\n    if (game.input.right) {\n      this.rotation += this.rotationSpeed;\n    }\n\n    if (this.rotation >= 360) {\n      this.rotation -= 360;\n    }\n\n    if (this.rotation < 0) {\n      this.rotation += 360;\n    } // Change velocity vector when engine is on\n\n\n    if (game.input.forward) {\n      this.velocity.x -= Math.sin(-this.rotation * Math.PI / 180) * this.speed;\n      this.velocity.y -= Math.cos(-this.rotation * Math.PI / 180) * this.speed;\n      this.inertia = this.inertiaMax; // Draw flame\n\n      this.points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 0,\n        y: -20\n      }, {\n        x: -10,\n        y: 10\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        x: 3,\n        y: 8\n      }, {\n        x: 0,\n        y: 15\n      }, {\n        x: -3,\n        y: 8\n      }];\n    } else {\n      // Hide flame\n      this.points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 0,\n        y: -20\n      }, {\n        x: -10,\n        y: 10\n      }];\n    } // fire\n\n\n    if (game.input.fire && Date.now() - this.shootDate > 300) {\n      var b = new Bullet_Bullet(game, this);\n      b.Start();\n      game.objects.push(b);\n      this.shootDate = Date.now();\n    } // Add inertia\n\n\n    this.position.x += this.velocity.x;\n    this.position.y += this.velocity.y;\n    this.velocity.x *= this.inertia;\n    this.velocity.y *= this.inertia; // Teleporting\n\n    if (this.position.x > game.canvas.width) {\n      this.position.x -= game.canvas.width;\n    }\n\n    if (this.position.x < 0) {\n      this.position.x += game.canvas.width;\n    }\n\n    if (this.position.y > game.canvas.height) {\n      this.position.y -= game.canvas.height;\n    }\n\n    if (this.position.y < 0) {\n      this.position.y += game.canvas.height;\n    } // Check intersection with asteroid\n\n\n    var pos = this.position;\n    var verts = this.points;\n    var collision = false;\n    var angle = this.rotation * Math.PI / 180;\n    var asteroidCount = 0;\n    game.eachByName("asteroid", function (node) {\n      asteroidCount++;\n\n      if (Math.sqrt((node.position.x - pos.x) * (node.position.x - pos.x) + (node.position.y - pos.y) * (node.position.y - pos.y)) < 130) {\n        for (var i = 0; i < verts.length; i++) {\n          var s1 = i;\n          var s2 = i + 1 < verts.length ? i + 1 : 0;\n          var rs1 = RotatePoint({\n            x: verts[s1].x,\n            y: verts[s1].y\n          }, {\n            x: 0,\n            y: 0\n          }, angle);\n          var rs2 = RotatePoint({\n            x: verts[s2].x,\n            y: verts[s2].y\n          }, {\n            x: 0,\n            y: 0\n          }, angle);\n\n          for (var j = 0; j < node.points.length; j++) {\n            var n1 = j;\n            var n2 = j + 1 < node.points.length ? j + 1 : 0;\n            var rn1 = RotatePoint({\n              x: node.points[n1].x,\n              y: node.points[n1].y\n            }, {\n              x: 0,\n              y: 0\n            }, node.rotation * Math.PI / 180);\n            var rn2 = RotatePoint({\n              x: node.points[n2].x,\n              y: node.points[n2].y\n            }, {\n              x: 0,\n              y: 0\n            }, node.rotation * Math.PI / 180);\n\n            if (CheckIntersection({\n              x: rs1.x + pos.x,\n              y: rs1.y + pos.y\n            }, {\n              x: rs2.x + pos.x,\n              y: rs2.y + pos.y\n            }, {\n              x: rn1.x + node.position.x,\n              y: rn1.y + node.position.y\n            }, {\n              x: rn2.x + node.position.x,\n              y: rn2.y + node.position.y\n            })) {\n              collision = true;\n            }\n          }\n        }\n      }\n    });\n\n    if (collision) {\n      this.delete = true;\n      var burst = new Burst_Burst({\n        position: this.position,\n        color: game.color\n      }, game);\n      game.objects.push(burst);\n      EngGameMessage("#g-leaderboard", game.score);\n      document.querySelector("#g-endgame").style.display = "block";\n    } // Make new asteroids\n\n\n    if (asteroidCount < 1) {\n      for (var i = 0; i < 4; i++) {\n        var rock = new Asteroid_Asteroid(80, game);\n        rock.Start();\n        game.objects.push(rock);\n      }\n    }\n  };\n\n  return ship;\n}\n// CONCATENATED MODULE: ./src/index.js\n/**\n * Cross-browser wrapper for function "requestAnimationFrame"\n */\nwindow.requestAnimFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\n\n\n\n\n/**********************************************************************************/\n\n/* Making new game object */\n\nvar src_game = new GameEngine("#g-game", "#g-score");\nsrc_game.color = "";\n\nif (typeof Storage !== "undefined") {\n  src_game.color = localStorage["game.color"] || "#0F0";\n  var c = 0;\n\n  switch (src_game.color) {\n    case "#F00":\n      c = 1;\n      break;\n\n    case "#06F":\n      c = 2;\n      break;\n\n    default:\n      c = 0;\n  }\n\n  ChangeGameColor(c, src_game);\n}\n\nvar src_ship = makeShip(src_game);\nsrc_game.objects.push(src_ship);\n/* Making procedural asteroids */\n\nfor (var src_i = 0; src_i < 4; src_i++) {\n  var src_rock = new Asteroid_Asteroid(80, src_game);\n  src_rock.Start();\n  src_game.objects.push(src_rock);\n}\n/* Run game */\n\n\nsrc_game.Run();\n\n//# sourceURL=webpack:///./src/index.js_+_7_modules?')}]);